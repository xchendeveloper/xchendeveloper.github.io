# java内存模型
<br>
翻译原文：http://tutorials.jenkov.com/java-concurrency/java-memory-model.html

java内存模型指java虚拟机在计算机内存中的工作方式。java虚拟机可以看做是一个计算机，所以自然会包含一个内存模型。

如果你想设计一个正确行为的并发程序，理解java虚拟机内存模型是非常重要的。java内存模型描述了线程间通信和正确获取共享内存的行为。

jdk1.5之前的内存模型是比较粗糙的，在jdk1.5中对内存模型进行了重构，并且一直沿用至今。（当前jdk1.8中仍采用)

## java内存模型详细

java内存模型在JVM中将内存定义为两种类型：线程栈、堆。

下图是逻辑示图：

![](assets/003/java-memory-model-1.png)  

每个运行在JVM中的线程拥有一个自己的线程栈（thread stack)。线程栈中存在了线程当前执行的方法信息。
线程栈中还包含了所有正在被执行的方法的局部变量。每个线程只能直接访问自己的线程栈，任何线程无法访问除自身之外的其他线程创建的局部变量。
即使是执行相同代码的两个线程，每个线程都会在自己的线程栈中创建自己的局部变量。
所有基本类型的变量（ boolean, byte, short, char, int, long, float, double ）都直接存放在线程栈中。并对其他线程不可见。
线程间可以进行基本类型的变量传递，但传递的并不是变量本身，而是变量的拷贝副本。

堆中包含了java应用所有线程创建的所有对象。包含（ Byte, Integer, Long ）等包装对象。无论是局部变量创建，还是成员变量创建，都存放在堆中。

下面是栈中存在方法和局部变量的示意图：

![](assets/003/java-memory-model-2.png)  

一个本地变量如果是基本类型，则直接存放在栈中。

一个本地变量如果是一个对象的引用，则引用存在在栈中，但所引用的对象存放在堆中。

一个对象可能包含一些方法，这些方法又可能会包含一些本地变量，这些本地变量存放在栈中，即使这个方法所属的对象存放在堆中。

一个对象的成员变量和对象一起存放在堆中，（无论是基本类型还是引用类型）

静态变量存放在堆中（和class的定义存放在一起，class本身也是一个对象）

在堆中的对象可以被所有拥有它的引用的线程访问，一个线程可以访问这个对象，则可以访问这个对象的成员变量，如果两个线程同一时间调用一个对象上的一个方法，
他们可以同时访问对象的成员变量，但是每个线程都会创建所使用方法的本地变量的副本。

下面是示意图：

![](assets/003/java-memory-model-3.png)  
